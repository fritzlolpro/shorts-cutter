# Shorts Cutter — Детальная документация по имплементации

## Общий план реализации

### Этап 1: Подготовка зависимостей и базовой структуры

#### 1.1 Обновление Cargo.toml
Добавить необходимые зависимости:
```toml
[dependencies]
clap = { version = "4.0", features = ["derive"] }
tokio = { version = "1.0", features = ["full"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter", "fmt"] }
chrono = { version = "0.4", features = ["serde"] }
serde = { version = "1.0", features = ["derive"] }
anyhow = "1.0"
thiserror = "1.0"
```

#### 1.2 Создание модульной структуры
Создать файлы в `src/`:
- `cli.rs` — парсинг аргументов командной строки
- `config.rs` — конфигурация приложения
- `processor.rs` — основная логика обработки
- `worker.rs` — пул воркеров для параллельной обработки
- `ffmpeg.rs` — работа с FFmpeg командами
- `logger.rs` — настройка и управление логированием
- `error.rs` — кастомные типы ошибок
- `utils.rs` — вспомогательные функции

---

## Этап 2: Имплементация CLI интерфейса

### 2.1 Создание структуры аргументов в cli.rs

#### Требования к CLI:
- `--input, -i` — обязательный путь к папке с исходными файлами
- `--output, -o` — обязательный путь к папке для результатов
- `--threads, -t` — опциональное количество потоков (по умолчанию: количество CPU ядер)
- `--help, -h` — автоматическая справка от clap
- `--version, -V` — версия программы

#### Детальная реализация:
1. Использовать derive API clap для автоматического парсинга
2. Добавить валидацию путей на уровне CLI (проверка существования input директории)
3. Реализовать логику определения количества потоков по умолчанию
4. Добавить красивое форматирование help сообщений

### 2.2 Валидация входных параметров
1. Проверить существование input директории
2. Проверить права на запись в output директорию (создать если не существует)
3. Проверить корректность значения threads (больше 0, не больше разумного лимита)
4. Проверить доступность FFmpeg в PATH

---

## Этап 3: Система логирования

### 3.1 Настройка tracing в logger.rs

#### Требования к логированию:
- Один лог-файл в output директории
- Имя файла: `shorts-cutter-YYYYMMDD-HHMMSS.log`
- Формат записей: `[YYYY-MM-DD HH:MM:SS] LEVEL: message`
- Логирование в файл И в консоль с разными уровнями

#### Детальная реализация:
1. Создать функцию инициализации логгера с параметром output_dir
2. Настроить многоуровневое логирование:
   - TRACE/DEBUG — только в файл
   - INFO — в консоль и файл
   - WARN/ERROR — в консоль и файл с выделением
3. Реализовать функции для структурированного логирования операций:
   - `log_file_start(filename)`
   - `log_ffmpeg_command(cmd)`
   - `log_file_success(input, output, duration)`
   - `log_file_error(input, error_msg)`
   - `log_summary(success_count, error_count, total_duration)`

### 3.2 Форматирование сообщений
1. Стандартизировать формат сообщений согласно примеру в дизайн-доке
2. Добавить измерение времени выполнения для каждого файла
3. Реализовать функцию генерации итогового отчета

---

## Этап 4: FFmpeg интеграция

### 4.1 Создание FFmpeg команд в ffmpeg.rs

#### Жестко заданный шаблон команды:
```bash
ffmpeg -i <infile> -i <infile> -filter_complex "[0:v]scale=2276:1280,boxblur=4[bg];[1:v]scale=720:-1[fg];[bg][fg]overlay=(W-w)/2:(H-h)/2[tmp];[tmp]crop=720:1280:(2276-720)/2:0[out]" -map "[out]" -map 0:a <outfile>
```

#### Детальная реализация:
1. Создать функцию `build_ffmpeg_command(input_path, output_path) -> Command`
2. Добавить проверку существования FFmpeg в системе
3. Реализовать функцию `check_ffmpeg_availability() -> Result<(), Error>`
4. Создать функцию `execute_ffmpeg_async(cmd) -> Result<(), Error>` с:
   - Захватом stdout/stderr
   - Обработкой кодов возврата
   - Таймаутом выполнения
   - Логированием полного вывода FFmpeg

### 4.2 Обработка ошибок FFmpeg
1. Парсинг stderr вывода FFmpeg для извлечения полезной информации об ошибках
2. Классификация типов ошибок (файл не найден, неправильный формат, недостаток места и т.д.)
3. Создание информативных сообщений об ошибках для пользователя

---

## Этап 5: Файловые операции и обработка

### 5.1 Поиск и фильтрация файлов в processor.rs

#### Требования:
- Рекурсивный поиск всех .mp4 файлов в input директории
- Генерация путей для output файлов с суффиксом "-short"
- Проверка на перезапись существующих файлов

#### Детальная реализация:
1. Создать функцию `find_mp4_files(input_dir) -> Vec<PathBuf>`
2. Реализовать `generate_output_path(input_path, output_dir) -> PathBuf`
3. Добавить логику обработки конфликтов имен (пропускать или перезаписывать)
4. Создать структуру `FileTask { input: PathBuf, output: PathBuf }`

### 5.2 Создание задач обработки
1. Функция `create_processing_tasks(files, output_dir) -> Vec<FileTask>`
2. Валидация каждой задачи перед добавлением в очередь
3. Логирование количества найденных файлов и созданных задач

---

## Этап 6: Параллельная обработка

### 6.1 Создание worker pool в worker.rs

#### Архитектура:
- Использовать `tokio::sync::Semaphore` для ограничения количества параллельных задач
- Создать канал для передачи задач между main thread и воркерами
- Собирать результаты выполнения для финального отчета

#### Детальная реализация:
1. Создать структуру `WorkerPool` с методами:
   - `new(thread_count: usize) -> Self`
   - `execute_tasks(tasks: Vec<FileTask>) -> ProcessingResult`
2. Реализовать `ProcessingResult` с полями:
   - `successful: Vec<(PathBuf, PathBuf, Duration)>`
   - `failed: Vec<(PathBuf, String)>`
   - `total_duration: Duration`
3. Создать async функцию `process_single_file(task: FileTask) -> TaskResult`

### 6.2 Обработка ошибок и устойчивость
1. Реализовать graceful shutdown при получении SIGINT/SIGTERM
2. Продолжение обработки остальных файлов при ошибке в одном
3. Сбор детальной статистики по каждому файлу
4. Retry логика для временных ошибок (если FFmpeg вернул определенные коды ошибок)

---

## Этап 7: Главная функция и оркестрация

### 7.1 Структура main.rs

#### Последовательность выполнения:
1. Парсинг аргументов командной строки
2. Инициализация логирования
3. Проверка доступности FFmpeg
4. Поиск файлов для обработки
5. Создание worker pool
6. Запуск обработки
7. Генерация финального отчета
8. Завершение с соответствующим exit code

#### Детальная реализация:
1. Создать функцию `async fn run() -> Result<(), Box<dyn std::error::Error>>`
2. Обернуть main в tokio runtime
3. Добавить обработку всех типов ошибок с информативными сообщениями
4. Реализовать функцию `print_final_report(result: ProcessingResult)`
5. Настроить правильные exit codes (0 для успеха, 1 для критических ошибок, 2 для частичного успеха)

### 7.2 Обработка сигналов и graceful shutdown
1. Установить обработчики сигналов для корректного завершения
2. Реализовать механизм отмены выполняющихся задач
3. Сохранение промежуточных результатов при принудительном завершении

---

## Этап 8: Обработка ошибок и типы данных

### 8.1 Создание кастомных типов ошибок в error.rs

#### Типы ошибок:
- `ConfigError` — ошибки конфигурации и CLI аргументов
- `FileSystemError` — ошибки работы с файловой системой
- `FfmpegError` — ошибки выполнения FFmpeg
- `LoggingError` — ошибки системы логирования

#### Детальная реализация:
1. Использовать thiserror для автоматической генерации Display impl
2. Создать enum `ShortsCutterError` объединяющий все типы ошибок
3. Реализовать From traits для конвертации между типами ошибок
4. Добавить поле context к каждому типу ошибки для дополнительной информации

### 8.2 Результирующие типы
1. Создать type aliases для часто используемых Result типов
2. Реализовать helper функции для создания ошибок с контекстом
3. Добавить функции для логирования ошибок в стандартизированном формате

---

## Этап 9: Конфигурация и настройки

### 9.1 Создание config.rs для централизованного управления настройками

#### Настройки приложения:
- Шаблон FFmpeg команды (пока hardcoded, но в структурированном виде)
- Форматы входных файлов (пока только .mp4)
- Суффикс для output файлов (пока "-short")
- Настройки логирования
- Лимиты и таймауты

#### Детальная реализация:
1. Создать структуру `AppConfig` с методом `default()`
2. Добавить константы для всех магических значений
3. Реализовать валидацию конфигурации
4. Подготовить инфраструктуру для будущего добавления config файлов

---

## Этап 10: Тестирование

### 10.1 Unit тесты
1. Тесты для CLI парсинга с различными комбинациями аргументов
2. Тесты для функций генерации путей и имен файлов
3. Тесты для FFmpeg команд generation
4. Тесты для обработки ошибок
5. Mock тесты для FFmpeg execution

### 10.2 Integration тесты
1. Создать тестовые video файлы в `tests/fixtures/`
2. Тесты end-to-end выполнения с реальными файлами
3. Тесты производительности с большим количеством файлов
4. Тесты обработки ошибочных ситуаций

---

## Этап 11: Документация и отладка

### 11.1 Расширенное логирование для отладки
1. Добавить подробное логирование всех этапов выполнения
2. Реализовать профилирование времени выполнения
3. Добавить метрики использования ресурсов

### 11.2 Пользовательская документация
1. Обновить README.md с примерами использования
2. Создать man page или подробный --help
3. Добавить примеры различных сценариев использования

---

## Порядок имплементации модулей

**Рекомендуемая последовательность:**

1. **error.rs** — базовые типы ошибок
2. **config.rs** — конфигурация и константы  
3. **cli.rs** — парсинг аргументов командной строки
4. **logger.rs** — система логирования
5. **utils.rs** — вспомогательные функции для работы с файлами
6. **ffmpeg.rs** — интеграция с FFmpeg
7. **processor.rs** — поиск файлов и создание задач
8. **worker.rs** — параллельная обработка
9. **main.rs** — главная функция и оркестрация
10. **tests/** — модульные и интеграционные тесты

Каждый модуль должен быть полностью реализован и протестирован перед переходом к следующему.
